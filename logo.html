<html>
<div class="fullScreen" id="fullScreen">
    <canvas id="canvas2d"></canvas>
</div>
</html>

<style media="screen" type="text/css">
html, body { 
    overflow: hidden; 
    background: #000; 
    padding: 0px; margin: 0px; 
    width: 100%; height: 100%; 
}
.fullScreen { 
    height: 100%; 
}
</style>



<script type="text/javascript">
/**
 * The Logos in our Logofield!
 * Logos coordinate system is relative to the CENTER of the canvas
 * @param  {number} x 
 * @param  {number} y
 */
var Logo = function(x, y, image) {
    this.image = image;
    this.x = x;
    this.y = y;
    this.slope = y / x; // This only works because our origin is always (0,0)
    this.opacity = 0;
    this.speed = Math.max(Math.random() * 3, 1);
};

/**
 * Compute the distance of this Logo relative to any other point in space.
 * 
 * @param  {int} originX
 * @param  {int} originY
 * 
 * @return {float} The distance of this Logo to the given origin
 */
Logo.prototype.distanceTo = function(originX, originY) {
    return Math.sqrt(Math.pow(originX - this.x, 2) + Math.pow(originY - this.y, 2));
};

/**
 * Reinitializes this Logo's attributes, without re-creating it 
 * 
 * @param  {number} x 
 * @param  {number} y
 * 
 * @return {Logo} this Logo
 */
Logo.prototype.resetPosition = function(x, y, image) {
    Logo.apply(this, arguments);
    return this;
};

/**
 * The BigBang factory creates Logos (Should be called LogoFactory, but that is
 * a WAY LESS COOL NAME! 
 * @type {Object}
 */
var BigBang = {
    /**
     * Returns a random Logo within a region of the space.
     * 
     * @param  {number} minX minimum X coordinate of the region
     * @param  {number} minY minimum Y coordinate of the region
     * @param  {number} maxX maximum X coordinate of the region
     * @param  {number} maxY maximum Y coordinate of the region
     * 
     * @return {Logo} The random Logo
     */
    getRandomLogo: function(minX, minY, maxX, maxY, image) {
        var coords = BigBang.getRandomPosition(minX, minY, maxX, maxY);
        return new Logo(coords.x, coords.y, image);
    },

    /**
     * Gets a random (x,y) position within a bounding box
     * 
     * 
     * @param  {number} minX minimum X coordinate of the region
     * @param  {number} minY minimum Y coordinate of the region
     * @param  {number} maxX maximum X coordinate of the region
     * @param  {number} maxY maximum Y coordinate of the region
     * 
     * @return {Object} An object with random {x, y} positions
     */
    getRandomPosition: function(minX, minY, maxX, maxY) {
        return {
            x: Math.floor((Math.random() * maxX) + minX),
            y: Math.floor((Math.random() * maxY) + minY)
        };
    }
};

/**
 * Constructor function of our Logofield. This just prepares the DOM nodes where
 * the scene will be rendered.
 * 
 * @param {string} canvasId The DOM Id of the <div> containing a <canvas> tag
 */
var LogoField = function(containerId) {
    this.container = document.getElementById(containerId);
    this.canvasElem = this.container.getElementsByTagName('canvas')[0];
    this.canvas = this.canvasElem.getContext('2d');

    this.width = this.container.offsetWidth;
    this.height = this.container.offsetHeight;

    this.logoField = [];
};

/**
 * Updates the properties for every Logo for the next frame to be rendered
 */
LogoField.prototype._updateLogoField = function() {
    var i, 
        logo, 
        randomLoc, 
        increment;

    for (i = 0; i < this.numLogos; i++) {
        logo = this.logoField[i];
        
        logo.speed=Math.abs(Math.sqrt(logo.x*logo.x+logo.y*logo.y)) /100;
        increment = Math.min(logo.speed, Math.abs(logo.speed / logo.slope));
        logo.x += (logo.x > 0) ? increment : -increment;
        logo.y = logo.slope * logo.x;
        
        logo.opacity += logo.speed / 100;
        
        // Recycle Logo obj if it goes out of the frame
        if ((Math.abs(logo.x) > this.width / 2) || 
            (Math.abs(logo.y) > this.height / 2)) {
            //randomLoc = BigBang.getRandomPosition(
            //    -this.width / 2, -this.height / 2, 
            //       this.width, this.height
            //);
            randomLoc = BigBang.getRandomPosition(
                -this.width / 10, -this.height / 10, 
                   this.width / 5, this.height / 5
            );
            logo.resetPosition(randomLoc.x, randomLoc.y, logo.image);
        }
    }
};

/**
 * Renders the whole Logofield (background + Logos)
 * This method could be made more efficient by just blipping each Logo,
 * and not redrawing the whole frame
 */
LogoField.prototype._renderLogoField = function() {
    var i,
        logo;
    // Background
    this.canvas.fillStyle = "rgba(0, 0, 0, 1)";
    this.canvas.fillRect(0, 0, this.width, this.height);
    // Logos
    for (i = 0; i < this.numLogos; i++) {
        logo = this.logoField[i];
        this.canvas.fillStyle = "rgba(255, 255, 255, " + logo.opacity + ")";
        this.canvas.fillRect(
            logo.x + this.width / 2, 
            logo.y + this.height / 2, 
            2, 2);
        //this.canvas.save();
        //this.canvas.translate(logo.x + this.width / 2,logo.y + this.height / 2)
        //this.canvas.scale(0.1,0.1);
	    //this.canvas.scale(0.1,0.1);
        this.canvas.drawImage(logo.image,
        			logo.x + this.width / 2,logo.y + this.height / 2,
        			30*logo.speed,30*logo.speed);
        			
	var imageData = this.canvas.getImageData(logo.x + this.width / 2,logo.y + this.height / 2,
        			30*logo.speed,30*logo.speed);
    var pixels = imageData.data;
    var numPixels = pixels.length;
    this.canvas.clearRect(logo.x + this.width / 2,logo.y + this.height / 2,
        			30*logo.speed,30*logo.speed);
    for (var i = 0; i < numPixels; i++) {
        pixels[i*4] = 0;
        pixels[i*4+1] = 100;
        pixels[i*4+2] = 0;
    }
    this.canvas.putImageData(imageData, logo.x + this.width / 2,logo.y + this.height / 2);
    
    	//this.canvas.restore();
    }
};


/**
 * Function that handles the animation of each frame. Update the Logofield
 * positions and re-render
 */
LogoField.prototype._renderFrame = function(elapsedTime) {
    var timeSinceLastFrame = elapsedTime - (this.prevFrameTime || 0);
    
    window.requestAnimationFrame(this._renderFrame.bind(this));

    // Skip frames unless at least 30ms have passed since the last one
    // (Cap to ~30fps)
    if (timeSinceLastFrame >= 30 || !this.prevFrameTime) {
        this.prevFrameTime = elapsedTime;
        this._updateLogoField();
        this._renderLogoField();
    }
};

/**
 * Makes sure that the canvas size fits the size of its container
 */
LogoField.prototype._adjustCanvasSize = function(width, height) {
    // Set the canvas size to match the container ID (and cache values)
    this.width = this.canvasElem.width = width || this.container.offsetWidth;
    this.height = this.canvasElem.height = height || this.container.offsetHeight;
};

/**
 * This listener compares the old container size with the new one, and caches
 * the new values.
 */
LogoField.prototype._watchCanvasSize = function(elapsedTime) {
    var timeSinceLastCheck = elapsedTime - (this.prevCheckTime || 0),
        width,
        height;

    window.requestAnimationFrame(this._watchCanvasSize.bind(this));

    // Skip frames unless at least 333ms have passed since the last check
    // (Cap to ~3fps)
    if (timeSinceLastCheck >= 333 || !this.prevCheckTime) {
        this.prevCheckTime = elapsedTime;
        width = this.container.offsetWidth;
        height = this.container.offsetHeight;
        if (this.oldWidth !== width || this.oldHeight !== height) {
            this.oldWidth = width;
            this.oldHeight = height;
            this._adjustCanvasSize(width, height);
        }
    }
};

/**
 * Initializes the scene by resizing the canvas to the appropiate value, and
 * sets up the main loop.
 * @param {int} numLogos Number of Logos in our Logofield
 */
LogoField.prototype._initScene = function(numLogos) {

    var logoImage = new Image;
    logoImage.src = "windows_logo.png";
    logoImage.style.width = '10%';
	logoImage.style.height = 'auto';
	logoImage.crossOrigin = ''; 
	// no credentials flag. Same as 
	logoImage.crossOrigin='anonymous'

    	var i;
    	for (i = 0; i < this.numLogos; i++) {
        	this.logoField.push(
        	    BigBang.getRandomLogo(-this.width / 2, -this.height / 2, this.width, this.height, logoImage)
        	);
    }
    // Intervals not stored because I don't plan to detach them later...
    window.requestAnimationFrame(this._renderFrame.bind(this));
    window.requestAnimationFrame(this._watchCanvasSize.bind(this));
};

/**
 * Kicks off everything!
 * @param {int} numLogos The number of Logos to render
 * @param {int} maxLogoSpeed Maximum speed of the Logos (pixels / frame)
 */
LogoField.prototype.render = function(numLogos) {
    this.numLogos = numLogos || 100;
    this._initScene(this.numLogos);
};

/**
 * requestAnimationFrame shim layer with setTimeout fallback
 * @see http://paulirish.com/2011/requestanimationframe-for-smart-animating
 */
(function() {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelAnimationFrame = 
          window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];
    }
 
    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
              timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
 
    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}());

// Kick off!
var logoField = new LogoField('fullScreen').render(50);

</script>
